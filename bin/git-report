trap(:SIGINT) do
  exit 0
end

require 'fileutils'
require 'json'
require_relative '../private_lib/yargs'
require_relative '../private_lib/git'

usage = <<EOS
  Synopsis
    git report init --main-branch REF
    git report run
    git report clean

  Options
    --main-branch-ref REF
      Set the main branch. This is used to determine divergent branches.
      Not that this MUST be the full ref name as output by `git show-ref`.
      That is, it should start with "refs/", as in "refs/remotes/origin/master"
EOS

# Using at_exit so we can define functions below (just for a top-down reading experience)
at_exit do
  ###
  # Parse arguments, dispatch commands
  ###

  yargs = Yargs.new(ARGV, :consume)
  if yargs.flag(:h)
    puts usage
    exit 0
  end

  mode = nil
  if ARGV.length < 1
    $stderr.puts usage
    exit 1
  end

  case ARGV.shift
  when 'init'
    main_branch = yargs.value('main-branch')
    unless main_branch
      $stderr.puts 'Missing --main-branch required option'
      $stderr.puts usage
      exit 1
    end
    do_init(main_branch)
  when 'run'
    do_run
  when 'update'
    do_update
  when 'clean'
    FileUtils.rm_rf 'git_report_state'
    FileUtils.rm_rf 'git_report_logs'
  else
    $stderr.puts "Invalid command"
    $stderr.puts usage
    exit 1
  end
end

###
# Functions
###

def do_init(main_branch)
  if !Dir.exists?('git_report_state') && !Dir.exists?('git_report_logs')
    unless check_cwd_is_git_repo
      $stderr.puts "Cannot intialize git report. This does not apper to be a git repo"
      exit 1
    end
    # TODO: Verify main-branch is recognized by git
    setup_git_report_files
    set_is_first_run(true)
    set_main_branch(main_branch)
  else
    $stderr.puts "Cannot reinitialize a git report project"
    exit 1
  end
  exit 0
end

def do_run
  if !Dir.exists?('git_report_state') && !Dir.exists?('git_report_logs')
    $stderr.puts "Cannot run git report in an unintialized folder. Please run `git report init`"
    exit 1
  end

  is_first_run = check_is_first_run
  main_branch = get_main_branch

  if is_first_run
    puts "Unsetting first run flag"
    set_is_first_run(false)
    puts "Logging all new commits to the repo"
    log_new_commits
  end

  #TODO Process.daemon
  spawn "git watch --all --exec 'git report update'"
  Process.waitall
end

def do_update
  ###
  # Ok, if we get here we should have been called by `git watch` as `git report update`
  # The fun begins!
  ###

  # We get three environment variables from `git watch`
  # $GIT_WATCH_REF - This is important, it tells us which ref changed, causing this script to run
  # $GIT_WATCH_PREVIOUS - Don't care about this, we're storing our own previous values in .GIT_REPORT_STATE
  # $GIT_WATCH_CURRENT - This will be the new value, already rev-parsed for us

  ref = ENV['GIT_WATCH_REF']
  current_head = ENV['GIT_WATCH_CURRENT']
  previous_values = get_previous_refs
  main_branch = get_main_branch
  prev_head = previous_values[ref]

  # Log the new ref head
  puts "Logging head for #{ref}"
  log_new_ref_head(ref, current_head)

  # Log the new ref commits for this branch
  puts "Logging ref commits for #{ref}"
  log_new_ref_commits(ref, prev_head)

  puts "Logging all new commits to repo"
  log_new_commits

  puts "Rewriting head state for #{ref}"
  rewrite_head_state(ref, current_head)
end

def rewrite_head_state(ref, head)
  previous_refs = get_previous_refs
  File.open('git_report_state/refs.json', 'w') do |f|
    previous_refs[ref] = head
    f.puts previous_refs.to_json
  end
end

def log_new_ref_head(ref, current_head)
  File.open('git_report_logs/heads_0.json', 'a') do |heads|
    heads.puts ({ ref: ref, kind: 'ref-head', head: current_head, time: Time.now.to_s }.to_json)
  end
end

def log_new_ref_commits(ref, prev_head)
  begin
    # Determine what commits we've yet to see for this branch
    new_commits = `git rev-list #{ref} #{ '^' + prev_head if prev_head}`.each_line.map { |l|
      l.strip
    }

    File.open('git_report_logs/ref_commits_0.json', 'a') do |ref_commits|
      new_commits.each do |sha|
        ref_commits.puts ({ kind: 'ref-commit', ref: ref, sha: sha }.to_json)
      end
    end
  rescue StandardError => ex
    $stderr.puts "Error logging new ref commits #{ex}"
  end
end

def log_new_commits
  new_commits = nil
  File.open('git_report_state/excluded_list.txt', 'r') do |exc|
    exclusions = exc.each_line.map { |l| l.strip }
    heads = Git.show_ref.map { |ref| ref[:name] }
    new_commits = Git.log(heads, exclusions)
  end

  # Log all commits from all references
  File.open('git_report_state/excluded_list.txt', 'a') do |exc|
    File.open('git_report_logs/commits_0.json', 'a') do |log|
      new_commits.each do |commit|
        data = commit.to_h
        if commit.parents.length == 1
          data[:kind] = 'commit'
        else
          data[:kind] = 'merge-commit'
        end
        log.puts(data.to_json)
        exc.puts(data[:sha])
      end
    end
  end
end

def check_is_first_run
  is_first_run = false
  File.open('git_report_state/first_run', 'r') do |f|
    is_first_run = f.read.strip == 'true'
  end
  is_first_run
end

def set_is_first_run(is)
  File.open('git_report_state/first_run', 'w') do |f|
    f.puts is.to_s
  end
end

def get_main_branch
  main_branch = nil
  File.open('git_report_state/main_branch', 'r') do |f|
    main_branch = f.read.strip
  end
  main_branch
end

def set_main_branch(main_branch)
  File.open('git_report_state/main_branch', 'w') do |f|
    f.puts "#{main_branch}\n"
  end
end

def setup_git_report_files
  Dir.mkdir('git_report_state')
  Dir.mkdir('git_report_logs')
  FileUtils.touch('git_report_logs/commits_0.json')
  FileUtils.touch('git_report_logs/heads_0.json')
  FileUtils.touch('git_report_logs/ref_commits_0.json')
  File.open('git_report_state/refs.json', 'w') do |f|
    f.puts '{}'
  end
  FileUtils.touch('git_report_state/excluded_list.txt')
end

def check_cwd_is_git_repo
  system "git status 1> #{File::NULL} 2> #{File::NULL}"
end

def get_previous_refs
  previous_values = nil
  File.open('git_report_state/refs.json', 'r') do |f|
    previous_values = JSON.parse(f.read)
  end
  previous_values
end
