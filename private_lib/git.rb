require 'pp'
require 'english'
require 'fileutils'
require 'shellwords'

# Just dispatches git commands in the working
# directory of the repo
class Repo
  attr_accessor :path

  def initialize(directory)
    @path = directory
  end

  def cd(&block)
    do_cd = (File.expand_path(Dir.pwd) != File.expand_path(@path))
    if do_cd
      pwd = Dir.pwd
      $stderr.puts "cd to #{@path}"
      Dir.chdir(@path)
    end
    yield
  ensure
    if do_cd
      $stderr.puts "cd back to #{pwd}"
      Dir.chdir(pwd)
    end
  end
  alias chdir cd

  def method_missing(name, *args, &block)
    if Git.respond_to? name
      self.cd do
        Git.send(name, *args, &block)
      end
    else
      raise StandardError.new("Method #{name} is undefined for class Repo")
    end
  end
end

class Commit
  attr_accessor :sha,
    :tree_sha,
    :parents,
    :author_name,
    :author_email,
    :author_date,
    :committer_name,
    :committer_email,
    :committer_date,
    :title

  # revision should be a single line as generated by `git log --pretty=format:"%H,%T,%P,%an,%ae,%ad,%cn,%ce,%cd,%s"`
  def self.parse(revision)
    tokens = revision.split(',')
    c = Commit.new
    c.sha = tokens[0]
    c.tree_sha = tokens[1]
    c.parents = tokens[2].split(/\s+/)
    c.author_name = tokens[3]
    c.author_email = tokens[4]
    c.author_date = tokens[5]
    c.committer_name = tokens[6]
    c.committer_email = tokens[7]
    c.committer_date = tokens[8]
    # If the commit title had a ',', it was split. Re-join it before storing
    c.title = tokens[9..(tokens.length-1)].join(',')
    c
  end

  # For easy serializtion (make a hash, add attributes as needed, then .to_json it)
  def to_h
    {
      :sha => self.sha,
      :tree_sha => self.tree_sha,
      :parents => self.parents,
      :author_name => self.author_name,
      :author_email => self.author_email,
      :author_date => self.author_date,
      :committer_name => self.committer_name,
      :committer_email => self.committer_email,
      :committer_date => self.committer_date,
      :title => self.title
    }
  end
end

class Branch
  attr_accessor :name, :commit

  def initialize(name, commit)
    @name = name
    @commit = commit
  end
end

module Git
  # All methods are "instance" methods to allow inclusion/extension
  # into other modules & classes. Extends itself to allow methods
  # to be called directly as module methods.
  extend self

  def git(argv)
    out = nil
    $stderr.puts "git #{argv}"
    out = IO.popen("git #{argv}", 'r')
    result = out.read
    Process.wait(out.pid)
    if $CHILD_STATUS.exitstatus != 0
      raise "git failed with exit status #{$CHILD_STATUS.exitstatus}"
    end
    result
  ensure
    out.close if out
  end

  def user_email
    git("config user.email").strip
  end

  def user_name
    git("config user.name").strip
  end

  def current_branch
    git('status')[/On branch ([^\n]+)\n/m, 1]
  end

  def branch_names
    git('branch -a').each_line.map { |l| l.gsub(/(^\s*\*\s*)|(\s*->.*$)/, '').strip }
  end

  def remote_uri(remote_name)
    git("remote -v")[/#{remote_name}\s+([^\n\s]+)/m, 1]
  end

  def merge_base(ref1, ref2)
    git("merge-base #{ref1} #{ref2}").strip
  end

  def log(include=[], exclude=[])
    result = []
    IO.popen("git log --stdin --date=iso --pretty=format:\"%H,%T,%P,%an,%ae,%ad,%cn,%ce,%cd,%s\"", 'r+') do |io|
      include.each do |inc|
        io.puts inc
      end
      exclude.each do |exc|
        io.puts "^#{exc}"
      end
      io.close_write
      while l = io.gets
        result.push Commit.parse(l)
      end
    end
    result
  end

  def show(commitish)
    Commit.pars(git("log --stdin --date=iso --pretty=format:\"%H,%T,%P,%an,%ae,%ad,%cn,%ce,%cd,%s\" #{commitish} --max-count=1")[0])
  end

  def diff(from_hash, to_hash=nil)
    if to_hash
      text = git("diff --numstat #{from_hash} #{to_hash}")
    else
      text = git("diff --numstat #{from_hash}")
    end

    text.split("\n")
      .map { |line|
        parts = line.split("\t")
      }.reject { |parts|
        # Binary files will have a '-' for the additions and deletions,
        # so we can use that to ignore them
        parts[0] == '-' && parts[1] == '-'
      }.map { |parts|
        { additions: parts[0].to_i, deletions: parts[1].to_i, file: parts[2] }
      }
  end

  def show_ref(pattern=nil)
    refs = []
    regex = pattern ? Regexp.new(pattern) : nil
    `git show-ref`.each_line do |l|
      tokens = l.strip.split(/\s+/)
      refs.push({ sha: tokens[0], name: tokens[1] }) unless regex && !(l =~ regex)
    end
    refs
  end

  def ref_names(pattern=nil)
    show_ref(pattern).map { |ref| ref[:name] }
  end
end
